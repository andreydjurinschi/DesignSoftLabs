## Статическое задание св-в

`классы:`

(x -> e.ex, e.g) 


```txt
Entity
 ├── Player
 └── Weapon
        └── MagicWeapon
```

есть абстрактный класс Entity, являющийся родителем для всех остальных представленных классов выше 

каждый последующий класс добавляет свои фиксированные, необходимые ему св-ва.  каждая сущность имеет фиксированные поля (их нельзя добавить, мы не можем их заменить). они представляют из себя тот набор
, который просто необходим этой сущности. **плюсы** такого подхода это лаконичный и понятный вид, хорошо работает в IDE (автокомплит, автоподстановка полей) и это удобно, когда мы знаем все сущности и их структуру заранее.

**минусы**: библиотека не знает зараннее какие св-ва нужны обычному пользователю, с чем он хочет работать и с чем нет.
конечно, мы можем в сущность пользователя подставить 20-40 всевозможных полей, однако они будут засорять значительный объем памяти, даже когда не будут использоваться. плюс с ростом функционала иерархия классов будет увеличиваться, что приведет к непонятной архитектуре проекта

___

## Использование интерфейсов

`классы:`
 
```txt
Entity
 ├── Player -> HasHp, HasMana
 └── Weapon -> 
        └── MagicWeapon
```

данный алгоритм действий обходит ограничения множественного наследования. теперь под каждую сущность можно создавать необходимые функционалу интерфейсы и имплементировать кол-во в рамках необходимого.

данный подход не усложняет иерархию классов и позволяет гибко настраивать последующую необходимую логику 


